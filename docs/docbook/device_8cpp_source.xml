<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_device_8cpp_source" xml:lang="en-US">
<title>device.cpp</title>
<indexterm><primary>src/device/device.cpp</primary></indexterm>
Go to the documentation of this file.<programlisting linenumbering="unnumbered"><anchor xml:id="_device_8cpp_source_1l00001"/>00001 <emphasis role="preprocessor">#include&#32;&quot;<link linkend="_device_8hpp">device.hpp</link>&quot;</emphasis>
<anchor xml:id="_device_8cpp_source_1l00002"/>00002 
<anchor xml:id="_device_8cpp_source_1l00003"/>00003 <emphasis role="comment">//&#32;std&#32;headers</emphasis>
<anchor xml:id="_device_8cpp_source_1l00004"/>00004 <emphasis role="preprocessor">#include&#32;&lt;cstring&gt;</emphasis>
<anchor xml:id="_device_8cpp_source_1l00005"/>00005 <emphasis role="preprocessor">#include&#32;&lt;iostream&gt;</emphasis>
<anchor xml:id="_device_8cpp_source_1l00006"/>00006 <emphasis role="preprocessor">#include&#32;&lt;set&gt;</emphasis>
<anchor xml:id="_device_8cpp_source_1l00007"/>00007 <emphasis role="preprocessor">#include&#32;&lt;unordered_set&gt;</emphasis>
<anchor xml:id="_device_8cpp_source_1l00008"/>00008 
<anchor xml:id="_device_8cpp_source_1l00009"/><link linkend="_namespace_blocky_vulkan">00009</link> <emphasis role="keyword">namespace&#32;</emphasis><link linkend="_namespace_blocky_vulkan">BlockyVulkan</link>&#32;{
<anchor xml:id="_device_8cpp_source_1l00010"/>00010 
<anchor xml:id="_device_8cpp_source_1l00011"/>00011 <emphasis role="comment">//&#32;local&#32;callback&#32;functions</emphasis>
<anchor xml:id="_device_8cpp_source_1l00012"/>00012 <emphasis role="keyword">static</emphasis>&#32;VKAPI_ATTR&#32;VkBool32&#32;VKAPI_CALL&#32;debugCallback(
<anchor xml:id="_device_8cpp_source_1l00013"/>00013 &#32;&#32;&#32;&#32;VkDebugUtilsMessageSeverityFlagBitsEXT&#32;messageSeverity,
<anchor xml:id="_device_8cpp_source_1l00014"/>00014 &#32;&#32;&#32;&#32;VkDebugUtilsMessageTypeFlagsEXT&#32;messageType,
<anchor xml:id="_device_8cpp_source_1l00015"/>00015 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;VkDebugUtilsMessengerCallbackDataEXT&#32;*pCallbackData,
<anchor xml:id="_device_8cpp_source_1l00016"/>00016 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;*pUserData)&#32;{
<anchor xml:id="_device_8cpp_source_1l00017"/>00017 &#32;&#32;&#32;&#32;std::cerr&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;validation&#32;layer:&#32;&quot;</emphasis>&#32;&lt;&lt;&#32;pCallbackData-&gt;pMessage&#32;&lt;&lt;&#32;std::endl;
<anchor xml:id="_device_8cpp_source_1l00018"/>00018 
<anchor xml:id="_device_8cpp_source_1l00019"/>00019 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;VK_FALSE;
<anchor xml:id="_device_8cpp_source_1l00020"/>00020 }
<anchor xml:id="_device_8cpp_source_1l00021"/>00021 
<anchor xml:id="_device_8cpp_source_1l00022"/><link linkend="_namespace_blocky_vulkan_1a9d56f27ff0564350bf95525132a7cf4f">00022</link> VkResult&#32;<link linkend="_namespace_blocky_vulkan_1a9d56f27ff0564350bf95525132a7cf4f">CreateDebugUtilsMessengerEXT</link>(
<anchor xml:id="_device_8cpp_source_1l00023"/>00023 &#32;&#32;&#32;&#32;VkInstance&#32;instance,
<anchor xml:id="_device_8cpp_source_1l00024"/>00024 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;VkDebugUtilsMessengerCreateInfoEXT&#32;*pCreateInfo,
<anchor xml:id="_device_8cpp_source_1l00025"/>00025 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;VkAllocationCallbacks&#32;*pAllocator,
<anchor xml:id="_device_8cpp_source_1l00026"/>00026 &#32;&#32;&#32;&#32;VkDebugUtilsMessengerEXT&#32;*pDebugMessenger)&#32;{
<anchor xml:id="_device_8cpp_source_1l00027"/>00027 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;func&#32;=&#32;(PFN_vkCreateDebugUtilsMessengerEXT)vkGetInstanceProcAddr(
<anchor xml:id="_device_8cpp_source_1l00028"/>00028 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;instance,
<anchor xml:id="_device_8cpp_source_1l00029"/>00029 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;vkCreateDebugUtilsMessengerEXT&quot;</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00030"/>00030 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(func&#32;!=&#32;<emphasis role="keyword">nullptr</emphasis>)&#32;{
<anchor xml:id="_device_8cpp_source_1l00031"/>00031 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;func(instance,&#32;pCreateInfo,&#32;pAllocator,&#32;pDebugMessenger);
<anchor xml:id="_device_8cpp_source_1l00032"/>00032 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
<anchor xml:id="_device_8cpp_source_1l00033"/>00033 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;VK_ERROR_EXTENSION_NOT_PRESENT;
<anchor xml:id="_device_8cpp_source_1l00034"/>00034 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00035"/>00035 }
<anchor xml:id="_device_8cpp_source_1l00036"/>00036 
<anchor xml:id="_device_8cpp_source_1l00037"/><link linkend="_namespace_blocky_vulkan_1aa99a2fcfffc744977e17b0af23cfeafb">00037</link> <emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_namespace_blocky_vulkan_1aa99a2fcfffc744977e17b0af23cfeafb">DestroyDebugUtilsMessengerEXT</link>(
<anchor xml:id="_device_8cpp_source_1l00038"/>00038 &#32;&#32;&#32;&#32;VkInstance&#32;instance,
<anchor xml:id="_device_8cpp_source_1l00039"/>00039 &#32;&#32;&#32;&#32;VkDebugUtilsMessengerEXT&#32;debugMessenger,
<anchor xml:id="_device_8cpp_source_1l00040"/>00040 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;VkAllocationCallbacks&#32;*pAllocator)&#32;{
<anchor xml:id="_device_8cpp_source_1l00041"/>00041 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;func&#32;=&#32;(PFN_vkDestroyDebugUtilsMessengerEXT)vkGetInstanceProcAddr(
<anchor xml:id="_device_8cpp_source_1l00042"/>00042 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;instance,
<anchor xml:id="_device_8cpp_source_1l00043"/>00043 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="stringliteral">&quot;vkDestroyDebugUtilsMessengerEXT&quot;</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00044"/>00044 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(func&#32;!=&#32;<emphasis role="keyword">nullptr</emphasis>)&#32;{
<anchor xml:id="_device_8cpp_source_1l00045"/>00045 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;func(instance,&#32;debugMessenger,&#32;pAllocator);
<anchor xml:id="_device_8cpp_source_1l00046"/>00046 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00047"/>00047 }
<anchor xml:id="_device_8cpp_source_1l00048"/>00048 
<anchor xml:id="_device_8cpp_source_1l00049"/>00049 <emphasis role="comment">//&#32;class&#32;member&#32;functions</emphasis>
<anchor xml:id="_device_8cpp_source_1l00050"/><link linkend="_class_blocky_vulkan_1_1_device_1a855af26281a51ebe1946e66fb1ed181a">00050</link> <link linkend="_class_blocky_vulkan_1_1_device_1a855af26281a51ebe1946e66fb1ed181a">Device::Device</link>(<link linkend="_class_blocky_vulkan_1_1_window">Window</link>&#32;&amp;window)&#32;:&#32;window{window}&#32;{
<anchor xml:id="_device_8cpp_source_1l00051"/>00051 &#32;&#32;&#32;&#32;createInstance();
<anchor xml:id="_device_8cpp_source_1l00052"/>00052 &#32;&#32;&#32;&#32;setupDebugMessenger();
<anchor xml:id="_device_8cpp_source_1l00053"/>00053 &#32;&#32;&#32;&#32;createSurface();
<anchor xml:id="_device_8cpp_source_1l00054"/>00054 &#32;&#32;&#32;&#32;pickPhysicalDevice();
<anchor xml:id="_device_8cpp_source_1l00055"/>00055 &#32;&#32;&#32;&#32;createLogicalDevice();
<anchor xml:id="_device_8cpp_source_1l00056"/>00056 &#32;&#32;&#32;&#32;createCommandPool();
<anchor xml:id="_device_8cpp_source_1l00057"/>00057 }
<anchor xml:id="_device_8cpp_source_1l00058"/>00058 
<anchor xml:id="_device_8cpp_source_1l00059"/><link linkend="_class_blocky_vulkan_1_1_device_1af4d1bbf15ca45ebc0df540f447701c35">00059</link> <link linkend="_class_blocky_vulkan_1_1_device_1af4d1bbf15ca45ebc0df540f447701c35">Device::~Device</link>()&#32;{
<anchor xml:id="_device_8cpp_source_1l00060"/>00060 &#32;&#32;&#32;&#32;vkDestroyCommandPool(device_,&#32;commandPool,&#32;<emphasis role="keyword">nullptr</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00061"/>00061 &#32;&#32;&#32;&#32;vkDestroyDevice(device_,&#32;<emphasis role="keyword">nullptr</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00062"/>00062 
<anchor xml:id="_device_8cpp_source_1l00063"/>00063 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_class_blocky_vulkan_1_1_device_1a6cb8cbe6257df6c3a3a5a1bfbd67d1e6">enableValidationLayers</link>)&#32;{
<anchor xml:id="_device_8cpp_source_1l00064"/>00064 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_namespace_blocky_vulkan_1aa99a2fcfffc744977e17b0af23cfeafb">DestroyDebugUtilsMessengerEXT</link>(instance,&#32;debugMessenger,&#32;<emphasis role="keyword">nullptr</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00065"/>00065 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00066"/>00066 
<anchor xml:id="_device_8cpp_source_1l00067"/>00067 &#32;&#32;&#32;&#32;vkDestroySurfaceKHR(instance,&#32;surface_,&#32;<emphasis role="keyword">nullptr</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00068"/>00068 &#32;&#32;&#32;&#32;vkDestroyInstance(instance,&#32;<emphasis role="keyword">nullptr</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00069"/>00069 }
<anchor xml:id="_device_8cpp_source_1l00070"/>00070 
<anchor xml:id="_device_8cpp_source_1l00071"/>00071 <emphasis role="keywordtype">void</emphasis>&#32;Device::createInstance()&#32;{
<anchor xml:id="_device_8cpp_source_1l00072"/>00072 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_class_blocky_vulkan_1_1_device_1a6cb8cbe6257df6c3a3a5a1bfbd67d1e6">enableValidationLayers</link>&#32;&amp;&amp;&#32;!checkValidationLayerSupport())&#32;{
<anchor xml:id="_device_8cpp_source_1l00073"/>00073 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">throw</emphasis>&#32;std::runtime_error(<emphasis role="stringliteral">&quot;validation&#32;layers&#32;requested,&#32;but&#32;not&#32;available!&quot;</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00074"/>00074 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00075"/>00075 
<anchor xml:id="_device_8cpp_source_1l00076"/>00076 &#32;&#32;&#32;&#32;VkApplicationInfo&#32;appInfo&#32;=&#32;{};
<anchor xml:id="_device_8cpp_source_1l00077"/>00077 &#32;&#32;&#32;&#32;appInfo.sType&#32;=&#32;VK_STRUCTURE_TYPE_APPLICATION_INFO;
<anchor xml:id="_device_8cpp_source_1l00078"/>00078 &#32;&#32;&#32;&#32;appInfo.pApplicationName&#32;=&#32;<emphasis role="stringliteral">&quot;LittleVulkanEngine&#32;App&quot;</emphasis>;
<anchor xml:id="_device_8cpp_source_1l00079"/>00079 &#32;&#32;&#32;&#32;appInfo.applicationVersion&#32;=&#32;VK_MAKE_VERSION(1,&#32;0,&#32;0);
<anchor xml:id="_device_8cpp_source_1l00080"/>00080 &#32;&#32;&#32;&#32;appInfo.pEngineName&#32;=&#32;<emphasis role="stringliteral">&quot;No&#32;Engine&quot;</emphasis>;
<anchor xml:id="_device_8cpp_source_1l00081"/>00081 &#32;&#32;&#32;&#32;appInfo.engineVersion&#32;=&#32;VK_MAKE_VERSION(1,&#32;0,&#32;0);
<anchor xml:id="_device_8cpp_source_1l00082"/>00082 &#32;&#32;&#32;&#32;appInfo.apiVersion&#32;=&#32;VK_API_VERSION_1_0;
<anchor xml:id="_device_8cpp_source_1l00083"/>00083 
<anchor xml:id="_device_8cpp_source_1l00084"/>00084 &#32;&#32;&#32;&#32;VkInstanceCreateInfo&#32;createInfo&#32;=&#32;{};
<anchor xml:id="_device_8cpp_source_1l00085"/>00085 &#32;&#32;&#32;&#32;createInfo.sType&#32;=&#32;VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
<anchor xml:id="_device_8cpp_source_1l00086"/>00086 &#32;&#32;&#32;&#32;createInfo.pApplicationInfo&#32;=&#32;&amp;appInfo;
<anchor xml:id="_device_8cpp_source_1l00087"/>00087 
<anchor xml:id="_device_8cpp_source_1l00088"/>00088 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;extensions&#32;=&#32;getRequiredExtensions();
<anchor xml:id="_device_8cpp_source_1l00089"/>00089 &#32;&#32;&#32;&#32;createInfo.enabledExtensionCount&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>uint32_t<emphasis role="keyword">&gt;</emphasis>(extensions.size());
<anchor xml:id="_device_8cpp_source_1l00090"/>00090 &#32;&#32;&#32;&#32;createInfo.ppEnabledExtensionNames&#32;=&#32;extensions.data();
<anchor xml:id="_device_8cpp_source_1l00091"/>00091 
<anchor xml:id="_device_8cpp_source_1l00092"/>00092 &#32;&#32;&#32;&#32;VkDebugUtilsMessengerCreateInfoEXT&#32;debugCreateInfo;
<anchor xml:id="_device_8cpp_source_1l00093"/>00093 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_class_blocky_vulkan_1_1_device_1a6cb8cbe6257df6c3a3a5a1bfbd67d1e6">enableValidationLayers</link>)&#32;{
<anchor xml:id="_device_8cpp_source_1l00094"/>00094 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;createInfo.enabledLayerCount&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>uint32_t<emphasis role="keyword">&gt;</emphasis>(validationLayers.size());
<anchor xml:id="_device_8cpp_source_1l00095"/>00095 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;createInfo.ppEnabledLayerNames&#32;=&#32;validationLayers.data();
<anchor xml:id="_device_8cpp_source_1l00096"/>00096 
<anchor xml:id="_device_8cpp_source_1l00097"/>00097 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;populateDebugMessengerCreateInfo(debugCreateInfo);
<anchor xml:id="_device_8cpp_source_1l00098"/>00098 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;createInfo.pNext&#32;=&#32;(VkDebugUtilsMessengerCreateInfoEXT&#32;*)&amp;debugCreateInfo;
<anchor xml:id="_device_8cpp_source_1l00099"/>00099 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
<anchor xml:id="_device_8cpp_source_1l00100"/>00100 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;createInfo.enabledLayerCount&#32;=&#32;0;
<anchor xml:id="_device_8cpp_source_1l00101"/>00101 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;createInfo.pNext&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;
<anchor xml:id="_device_8cpp_source_1l00102"/>00102 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00103"/>00103 
<anchor xml:id="_device_8cpp_source_1l00104"/>00104 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(vkCreateInstance(&amp;createInfo,&#32;<emphasis role="keyword">nullptr</emphasis>,&#32;&amp;instance)&#32;!=&#32;VK_SUCCESS)&#32;{
<anchor xml:id="_device_8cpp_source_1l00105"/>00105 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">throw</emphasis>&#32;std::runtime_error(<emphasis role="stringliteral">&quot;failed&#32;to&#32;create&#32;instance!&quot;</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00106"/>00106 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00107"/>00107 
<anchor xml:id="_device_8cpp_source_1l00108"/>00108 &#32;&#32;&#32;&#32;hasGflwRequiredInstanceExtensions();
<anchor xml:id="_device_8cpp_source_1l00109"/>00109 }
<anchor xml:id="_device_8cpp_source_1l00110"/>00110 
<anchor xml:id="_device_8cpp_source_1l00111"/>00111 <emphasis role="keywordtype">void</emphasis>&#32;Device::pickPhysicalDevice()&#32;{
<anchor xml:id="_device_8cpp_source_1l00112"/>00112 &#32;&#32;&#32;&#32;uint32_t&#32;deviceCount&#32;=&#32;0;
<anchor xml:id="_device_8cpp_source_1l00113"/>00113 &#32;&#32;&#32;&#32;vkEnumeratePhysicalDevices(instance,&#32;&amp;deviceCount,&#32;<emphasis role="keyword">nullptr</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00114"/>00114 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(deviceCount&#32;==&#32;0)&#32;{
<anchor xml:id="_device_8cpp_source_1l00115"/>00115 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">throw</emphasis>&#32;std::runtime_error(<emphasis role="stringliteral">&quot;failed&#32;to&#32;find&#32;GPUs&#32;with&#32;Vulkan&#32;support!&quot;</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00116"/>00116 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00117"/>00117 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;Device&#32;count:&#32;&quot;</emphasis>&#32;&lt;&lt;&#32;deviceCount&#32;&lt;&lt;&#32;std::endl;
<anchor xml:id="_device_8cpp_source_1l00118"/>00118 &#32;&#32;&#32;&#32;std::vector&lt;VkPhysicalDevice&gt;&#32;devices(deviceCount);
<anchor xml:id="_device_8cpp_source_1l00119"/>00119 &#32;&#32;&#32;&#32;vkEnumeratePhysicalDevices(instance,&#32;&amp;deviceCount,&#32;devices.data());
<anchor xml:id="_device_8cpp_source_1l00120"/>00120 
<anchor xml:id="_device_8cpp_source_1l00121"/>00121 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">auto</emphasis>&#32;&amp;<link linkend="_class_blocky_vulkan_1_1_device_1abd0f1af74c6907d4354112e1291db9aa">device</link>&#32;:&#32;devices)&#32;{
<anchor xml:id="_device_8cpp_source_1l00122"/>00122 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(isDeviceSuitable(<link linkend="_class_blocky_vulkan_1_1_device_1abd0f1af74c6907d4354112e1291db9aa">device</link>))&#32;{
<anchor xml:id="_device_8cpp_source_1l00123"/>00123 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;physicalDevice&#32;=&#32;<link linkend="_class_blocky_vulkan_1_1_device_1abd0f1af74c6907d4354112e1291db9aa">device</link>;
<anchor xml:id="_device_8cpp_source_1l00124"/>00124 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
<anchor xml:id="_device_8cpp_source_1l00125"/>00125 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00126"/>00126 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00127"/>00127 
<anchor xml:id="_device_8cpp_source_1l00128"/>00128 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(physicalDevice&#32;==&#32;VK_NULL_HANDLE)&#32;{
<anchor xml:id="_device_8cpp_source_1l00129"/>00129 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">throw</emphasis>&#32;std::runtime_error(<emphasis role="stringliteral">&quot;failed&#32;to&#32;find&#32;a&#32;suitable&#32;GPU!&quot;</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00130"/>00130 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00131"/>00131 
<anchor xml:id="_device_8cpp_source_1l00132"/>00132 &#32;&#32;&#32;&#32;vkGetPhysicalDeviceProperties(physicalDevice,&#32;&amp;<link linkend="_class_blocky_vulkan_1_1_device_1aa21b177cd0be90aec7ecb0179fd7e734">properties</link>);
<anchor xml:id="_device_8cpp_source_1l00133"/>00133 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;physical&#32;device:&#32;&quot;</emphasis>&#32;&lt;&lt;&#32;<link linkend="_class_blocky_vulkan_1_1_device_1aa21b177cd0be90aec7ecb0179fd7e734">properties</link>.deviceName&#32;&lt;&lt;&#32;std::endl;
<anchor xml:id="_device_8cpp_source_1l00134"/>00134 }
<anchor xml:id="_device_8cpp_source_1l00135"/>00135 
<anchor xml:id="_device_8cpp_source_1l00136"/>00136 <emphasis role="keywordtype">void</emphasis>&#32;Device::createLogicalDevice()&#32;{
<anchor xml:id="_device_8cpp_source_1l00137"/>00137 &#32;&#32;&#32;&#32;QueueFamilyIndices&#32;indices&#32;=&#32;findQueueFamilies(physicalDevice);
<anchor xml:id="_device_8cpp_source_1l00138"/>00138 
<anchor xml:id="_device_8cpp_source_1l00139"/>00139 &#32;&#32;&#32;&#32;std::vector&lt;VkDeviceQueueCreateInfo&gt;&#32;queueCreateInfos;
<anchor xml:id="_device_8cpp_source_1l00140"/>00140 &#32;&#32;&#32;&#32;std::set&lt;uint32_t&gt;&#32;uniqueQueueFamilies&#32;=&#32;{indices.graphicsFamily,&#32;indices.presentFamily};
<anchor xml:id="_device_8cpp_source_1l00141"/>00141 
<anchor xml:id="_device_8cpp_source_1l00142"/>00142 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">float</emphasis>&#32;queuePriority&#32;=&#32;1.f;
<anchor xml:id="_device_8cpp_source_1l00143"/>00143 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(uint32_t&#32;queueFamily&#32;:&#32;uniqueQueueFamilies)&#32;{
<anchor xml:id="_device_8cpp_source_1l00144"/>00144 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;VkDeviceQueueCreateInfo&#32;queueCreateInfo&#32;=&#32;{};
<anchor xml:id="_device_8cpp_source_1l00145"/>00145 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;queueCreateInfo.sType&#32;=&#32;VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
<anchor xml:id="_device_8cpp_source_1l00146"/>00146 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;queueCreateInfo.queueFamilyIndex&#32;=&#32;queueFamily;
<anchor xml:id="_device_8cpp_source_1l00147"/>00147 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;queueCreateInfo.queueCount&#32;=&#32;1;
<anchor xml:id="_device_8cpp_source_1l00148"/>00148 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;queueCreateInfo.pQueuePriorities&#32;=&#32;&amp;queuePriority;
<anchor xml:id="_device_8cpp_source_1l00149"/>00149 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;queueCreateInfos.push_back(queueCreateInfo);
<anchor xml:id="_device_8cpp_source_1l00150"/>00150 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00151"/>00151 
<anchor xml:id="_device_8cpp_source_1l00152"/>00152 &#32;&#32;&#32;&#32;VkPhysicalDeviceFeatures&#32;deviceFeatures&#32;=&#32;{};
<anchor xml:id="_device_8cpp_source_1l00153"/>00153 &#32;&#32;&#32;&#32;deviceFeatures.samplerAnisotropy&#32;=&#32;VK_TRUE;
<anchor xml:id="_device_8cpp_source_1l00154"/>00154 
<anchor xml:id="_device_8cpp_source_1l00155"/>00155 &#32;&#32;&#32;&#32;VkDeviceCreateInfo&#32;createInfo&#32;=&#32;{};
<anchor xml:id="_device_8cpp_source_1l00156"/>00156 &#32;&#32;&#32;&#32;createInfo.sType&#32;=&#32;VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
<anchor xml:id="_device_8cpp_source_1l00157"/>00157 
<anchor xml:id="_device_8cpp_source_1l00158"/>00158 &#32;&#32;&#32;&#32;createInfo.queueCreateInfoCount&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>uint32_t<emphasis role="keyword">&gt;</emphasis>(queueCreateInfos.size());
<anchor xml:id="_device_8cpp_source_1l00159"/>00159 &#32;&#32;&#32;&#32;createInfo.pQueueCreateInfos&#32;=&#32;queueCreateInfos.data();
<anchor xml:id="_device_8cpp_source_1l00160"/>00160 
<anchor xml:id="_device_8cpp_source_1l00161"/>00161 &#32;&#32;&#32;&#32;createInfo.pEnabledFeatures&#32;=&#32;&amp;deviceFeatures;
<anchor xml:id="_device_8cpp_source_1l00162"/>00162 &#32;&#32;&#32;&#32;createInfo.enabledExtensionCount&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>uint32_t<emphasis role="keyword">&gt;</emphasis>(deviceExtensions.size());
<anchor xml:id="_device_8cpp_source_1l00163"/>00163 &#32;&#32;&#32;&#32;createInfo.ppEnabledExtensionNames&#32;=&#32;deviceExtensions.data();
<anchor xml:id="_device_8cpp_source_1l00164"/>00164 
<anchor xml:id="_device_8cpp_source_1l00165"/>00165 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;might&#32;not&#32;really&#32;be&#32;necessary&#32;anymore&#32;because&#32;device&#32;specific&#32;validation&#32;layers</emphasis>
<anchor xml:id="_device_8cpp_source_1l00166"/>00166 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;have&#32;been&#32;deprecated</emphasis>
<anchor xml:id="_device_8cpp_source_1l00167"/>00167 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_class_blocky_vulkan_1_1_device_1a6cb8cbe6257df6c3a3a5a1bfbd67d1e6">enableValidationLayers</link>)&#32;{
<anchor xml:id="_device_8cpp_source_1l00168"/>00168 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;createInfo.enabledLayerCount&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>uint32_t<emphasis role="keyword">&gt;</emphasis>(validationLayers.size());
<anchor xml:id="_device_8cpp_source_1l00169"/>00169 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;createInfo.ppEnabledLayerNames&#32;=&#32;validationLayers.data();
<anchor xml:id="_device_8cpp_source_1l00170"/>00170 &#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;{
<anchor xml:id="_device_8cpp_source_1l00171"/>00171 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;createInfo.enabledLayerCount&#32;=&#32;0;
<anchor xml:id="_device_8cpp_source_1l00172"/>00172 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00173"/>00173 
<anchor xml:id="_device_8cpp_source_1l00174"/>00174 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(vkCreateDevice(physicalDevice,&#32;&amp;createInfo,&#32;<emphasis role="keyword">nullptr</emphasis>,&#32;&amp;device_)&#32;!=&#32;VK_SUCCESS)&#32;{
<anchor xml:id="_device_8cpp_source_1l00175"/>00175 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">throw</emphasis>&#32;std::runtime_error(<emphasis role="stringliteral">&quot;failed&#32;to&#32;create&#32;logical&#32;device!&quot;</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00176"/>00176 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00177"/>00177 
<anchor xml:id="_device_8cpp_source_1l00178"/>00178 &#32;&#32;&#32;&#32;vkGetDeviceQueue(device_,&#32;indices.graphicsFamily,&#32;0,&#32;&amp;graphicsQueue_);
<anchor xml:id="_device_8cpp_source_1l00179"/>00179 &#32;&#32;&#32;&#32;vkGetDeviceQueue(device_,&#32;indices.presentFamily,&#32;0,&#32;&amp;presentQueue_);
<anchor xml:id="_device_8cpp_source_1l00180"/>00180 }
<anchor xml:id="_device_8cpp_source_1l00181"/>00181 
<anchor xml:id="_device_8cpp_source_1l00182"/>00182 <emphasis role="keywordtype">void</emphasis>&#32;Device::createCommandPool()&#32;{
<anchor xml:id="_device_8cpp_source_1l00183"/>00183 &#32;&#32;&#32;&#32;QueueFamilyIndices&#32;queueFamilyIndices&#32;=&#32;<link linkend="_class_blocky_vulkan_1_1_device_1ad3ddfd3647179abd6d940be294e790c8">findPhysicalQueueFamilies</link>();
<anchor xml:id="_device_8cpp_source_1l00184"/>00184 
<anchor xml:id="_device_8cpp_source_1l00185"/>00185 &#32;&#32;&#32;&#32;VkCommandPoolCreateInfo&#32;poolInfo&#32;=&#32;{};
<anchor xml:id="_device_8cpp_source_1l00186"/>00186 &#32;&#32;&#32;&#32;poolInfo.sType&#32;=&#32;VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
<anchor xml:id="_device_8cpp_source_1l00187"/>00187 &#32;&#32;&#32;&#32;poolInfo.queueFamilyIndex&#32;=&#32;queueFamilyIndices.graphicsFamily;
<anchor xml:id="_device_8cpp_source_1l00188"/>00188 &#32;&#32;&#32;&#32;poolInfo.flags&#32;=
<anchor xml:id="_device_8cpp_source_1l00189"/>00189 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;VK_COMMAND_POOL_CREATE_TRANSIENT_BIT&#32;|&#32;VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;
<anchor xml:id="_device_8cpp_source_1l00190"/>00190 
<anchor xml:id="_device_8cpp_source_1l00191"/>00191 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(vkCreateCommandPool(device_,&#32;&amp;poolInfo,&#32;<emphasis role="keyword">nullptr</emphasis>,&#32;&amp;commandPool)&#32;!=&#32;VK_SUCCESS)&#32;{
<anchor xml:id="_device_8cpp_source_1l00192"/>00192 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">throw</emphasis>&#32;std::runtime_error(<emphasis role="stringliteral">&quot;failed&#32;to&#32;create&#32;command&#32;pool!&quot;</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00193"/>00193 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00194"/>00194 }
<anchor xml:id="_device_8cpp_source_1l00195"/>00195 
<anchor xml:id="_device_8cpp_source_1l00196"/>00196 <emphasis role="keywordtype">void</emphasis>&#32;Device::createSurface()&#32;{
<anchor xml:id="_device_8cpp_source_1l00197"/>00197 &#32;&#32;&#32;&#32;window.<link linkend="_class_blocky_vulkan_1_1_window_1a96d585feaed2d71904c337611dc935d6">CreateWindowSurface</link>(instance,&#32;&amp;surface_);
<anchor xml:id="_device_8cpp_source_1l00198"/>00198 }
<anchor xml:id="_device_8cpp_source_1l00199"/>00199 
<anchor xml:id="_device_8cpp_source_1l00200"/>00200 <emphasis role="keywordtype">bool</emphasis>&#32;Device::isDeviceSuitable(VkPhysicalDevice&#32;device)&#32;{
<anchor xml:id="_device_8cpp_source_1l00201"/>00201 &#32;&#32;&#32;&#32;QueueFamilyIndices&#32;indices&#32;=&#32;findQueueFamilies(<link linkend="_class_blocky_vulkan_1_1_device_1abd0f1af74c6907d4354112e1291db9aa">device</link>);
<anchor xml:id="_device_8cpp_source_1l00202"/>00202 
<anchor xml:id="_device_8cpp_source_1l00203"/>00203 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;extensionsSupported&#32;=&#32;checkDeviceExtensionSupport(<link linkend="_class_blocky_vulkan_1_1_device_1abd0f1af74c6907d4354112e1291db9aa">device</link>);
<anchor xml:id="_device_8cpp_source_1l00204"/>00204 
<anchor xml:id="_device_8cpp_source_1l00205"/>00205 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;swapChainAdequate&#32;=&#32;<emphasis role="keyword">false</emphasis>;
<anchor xml:id="_device_8cpp_source_1l00206"/>00206 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(extensionsSupported)&#32;{
<anchor xml:id="_device_8cpp_source_1l00207"/>00207 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;SwapChainSupportDetails&#32;swapChainSupport&#32;=&#32;querySwapChainSupport(<link linkend="_class_blocky_vulkan_1_1_device_1abd0f1af74c6907d4354112e1291db9aa">device</link>);
<anchor xml:id="_device_8cpp_source_1l00208"/>00208 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;swapChainAdequate&#32;=&#32;!swapChainSupport.formats.empty()&#32;&amp;&amp;&#32;!swapChainSupport.presentModes.empty();
<anchor xml:id="_device_8cpp_source_1l00209"/>00209 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00210"/>00210 
<anchor xml:id="_device_8cpp_source_1l00211"/>00211 &#32;&#32;&#32;&#32;VkPhysicalDeviceFeatures&#32;supportedFeatures;
<anchor xml:id="_device_8cpp_source_1l00212"/>00212 &#32;&#32;&#32;&#32;vkGetPhysicalDeviceFeatures(<link linkend="_class_blocky_vulkan_1_1_device_1abd0f1af74c6907d4354112e1291db9aa">device</link>,&#32;&amp;supportedFeatures);
<anchor xml:id="_device_8cpp_source_1l00213"/>00213 
<anchor xml:id="_device_8cpp_source_1l00214"/>00214 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;indices.isComplete()&#32;&amp;&amp;&#32;extensionsSupported&#32;&amp;&amp;&#32;swapChainAdequate&#32;&amp;&amp;
<anchor xml:id="_device_8cpp_source_1l00215"/>00215 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;supportedFeatures.samplerAnisotropy;
<anchor xml:id="_device_8cpp_source_1l00216"/>00216 }
<anchor xml:id="_device_8cpp_source_1l00217"/>00217 
<anchor xml:id="_device_8cpp_source_1l00218"/>00218 <emphasis role="keywordtype">void</emphasis>&#32;Device::populateDebugMessengerCreateInfo(
<anchor xml:id="_device_8cpp_source_1l00219"/>00219 &#32;&#32;&#32;&#32;VkDebugUtilsMessengerCreateInfoEXT&#32;&amp;createInfo)&#32;{
<anchor xml:id="_device_8cpp_source_1l00220"/>00220 &#32;&#32;&#32;&#32;createInfo&#32;=&#32;{};
<anchor xml:id="_device_8cpp_source_1l00221"/>00221 &#32;&#32;&#32;&#32;createInfo.sType&#32;=&#32;VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;
<anchor xml:id="_device_8cpp_source_1l00222"/>00222 &#32;&#32;&#32;&#32;createInfo.messageSeverity&#32;=&#32;VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT&#32;|
<anchor xml:id="_device_8cpp_source_1l00223"/>00223 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
<anchor xml:id="_device_8cpp_source_1l00224"/>00224 &#32;&#32;&#32;&#32;createInfo.messageType&#32;=&#32;VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT&#32;|
<anchor xml:id="_device_8cpp_source_1l00225"/>00225 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT&#32;|
<anchor xml:id="_device_8cpp_source_1l00226"/>00226 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;
<anchor xml:id="_device_8cpp_source_1l00227"/>00227 &#32;&#32;&#32;&#32;createInfo.pfnUserCallback&#32;=&#32;debugCallback;
<anchor xml:id="_device_8cpp_source_1l00228"/>00228 &#32;&#32;&#32;&#32;createInfo.pUserData&#32;=&#32;<emphasis role="keyword">nullptr</emphasis>;&#32;&#32;<emphasis role="comment">//&#32;Optional</emphasis>
<anchor xml:id="_device_8cpp_source_1l00229"/>00229 }
<anchor xml:id="_device_8cpp_source_1l00230"/>00230 
<anchor xml:id="_device_8cpp_source_1l00231"/>00231 <emphasis role="keywordtype">void</emphasis>&#32;Device::setupDebugMessenger()&#32;{
<anchor xml:id="_device_8cpp_source_1l00232"/>00232 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!<link linkend="_class_blocky_vulkan_1_1_device_1a6cb8cbe6257df6c3a3a5a1bfbd67d1e6">enableValidationLayers</link>)&#32;<emphasis role="keywordflow">return</emphasis>;
<anchor xml:id="_device_8cpp_source_1l00233"/>00233 &#32;&#32;&#32;&#32;VkDebugUtilsMessengerCreateInfoEXT&#32;createInfo;
<anchor xml:id="_device_8cpp_source_1l00234"/>00234 &#32;&#32;&#32;&#32;populateDebugMessengerCreateInfo(createInfo);
<anchor xml:id="_device_8cpp_source_1l00235"/>00235 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespace_blocky_vulkan_1a9d56f27ff0564350bf95525132a7cf4f">CreateDebugUtilsMessengerEXT</link>(instance,&#32;&amp;createInfo,&#32;<emphasis role="keyword">nullptr</emphasis>,&#32;&amp;debugMessenger)&#32;!=&#32;VK_SUCCESS)&#32;{
<anchor xml:id="_device_8cpp_source_1l00236"/>00236 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">throw</emphasis>&#32;std::runtime_error(<emphasis role="stringliteral">&quot;failed&#32;to&#32;set&#32;up&#32;debug&#32;messenger!&quot;</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00237"/>00237 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00238"/>00238 }
<anchor xml:id="_device_8cpp_source_1l00239"/>00239 
<anchor xml:id="_device_8cpp_source_1l00240"/>00240 <emphasis role="keywordtype">bool</emphasis>&#32;Device::checkValidationLayerSupport()&#32;{
<anchor xml:id="_device_8cpp_source_1l00241"/>00241 &#32;&#32;&#32;&#32;uint32_t&#32;layerCount;
<anchor xml:id="_device_8cpp_source_1l00242"/>00242 &#32;&#32;&#32;&#32;vkEnumerateInstanceLayerProperties(&amp;layerCount,&#32;<emphasis role="keyword">nullptr</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00243"/>00243 
<anchor xml:id="_device_8cpp_source_1l00244"/>00244 &#32;&#32;&#32;&#32;std::vector&lt;VkLayerProperties&gt;&#32;availableLayers(layerCount);
<anchor xml:id="_device_8cpp_source_1l00245"/>00245 &#32;&#32;&#32;&#32;vkEnumerateInstanceLayerProperties(&amp;layerCount,&#32;availableLayers.data());
<anchor xml:id="_device_8cpp_source_1l00246"/>00246 
<anchor xml:id="_device_8cpp_source_1l00247"/>00247 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;*layerName&#32;:&#32;validationLayers)&#32;{
<anchor xml:id="_device_8cpp_source_1l00248"/>00248 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;layerFound&#32;=&#32;<emphasis role="keyword">false</emphasis>;
<anchor xml:id="_device_8cpp_source_1l00249"/>00249 
<anchor xml:id="_device_8cpp_source_1l00250"/>00250 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">auto</emphasis>&#32;&amp;layerProperties&#32;:&#32;availableLayers)&#32;{
<anchor xml:id="_device_8cpp_source_1l00251"/>00251 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(strcmp(layerName,&#32;layerProperties.layerName)&#32;==&#32;0)&#32;{
<anchor xml:id="_device_8cpp_source_1l00252"/>00252 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;layerFound&#32;=&#32;<emphasis role="keyword">true</emphasis>;
<anchor xml:id="_device_8cpp_source_1l00253"/>00253 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
<anchor xml:id="_device_8cpp_source_1l00254"/>00254 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00255"/>00255 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00256"/>00256 
<anchor xml:id="_device_8cpp_source_1l00257"/>00257 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!layerFound)&#32;{
<anchor xml:id="_device_8cpp_source_1l00258"/>00258 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
<anchor xml:id="_device_8cpp_source_1l00259"/>00259 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00260"/>00260 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00261"/>00261 
<anchor xml:id="_device_8cpp_source_1l00262"/>00262 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
<anchor xml:id="_device_8cpp_source_1l00263"/>00263 }
<anchor xml:id="_device_8cpp_source_1l00264"/>00264 
<anchor xml:id="_device_8cpp_source_1l00265"/>00265 std::vector&lt;const&#32;char&#32;*&gt;&#32;Device::getRequiredExtensions()&#32;{
<anchor xml:id="_device_8cpp_source_1l00266"/>00266 &#32;&#32;&#32;&#32;uint32_t&#32;glfwExtensionCount&#32;=&#32;0;
<anchor xml:id="_device_8cpp_source_1l00267"/>00267 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>&#32;**glfwExtensions;
<anchor xml:id="_device_8cpp_source_1l00268"/>00268 &#32;&#32;&#32;&#32;glfwExtensions&#32;=&#32;glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount);
<anchor xml:id="_device_8cpp_source_1l00269"/>00269 
<anchor xml:id="_device_8cpp_source_1l00270"/>00270 &#32;&#32;&#32;&#32;std::vector&lt;const&#32;char&#32;*&gt;&#32;extensions(glfwExtensions,&#32;glfwExtensions&#32;+&#32;glfwExtensionCount);
<anchor xml:id="_device_8cpp_source_1l00271"/>00271 
<anchor xml:id="_device_8cpp_source_1l00272"/>00272 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_class_blocky_vulkan_1_1_device_1a6cb8cbe6257df6c3a3a5a1bfbd67d1e6">enableValidationLayers</link>)&#32;{
<anchor xml:id="_device_8cpp_source_1l00273"/>00273 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME);
<anchor xml:id="_device_8cpp_source_1l00274"/>00274 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00275"/>00275 
<anchor xml:id="_device_8cpp_source_1l00276"/>00276 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;extensions;
<anchor xml:id="_device_8cpp_source_1l00277"/>00277 }
<anchor xml:id="_device_8cpp_source_1l00278"/>00278 
<anchor xml:id="_device_8cpp_source_1l00279"/>00279 <emphasis role="keywordtype">void</emphasis>&#32;Device::hasGflwRequiredInstanceExtensions()&#32;{
<anchor xml:id="_device_8cpp_source_1l00280"/>00280 &#32;&#32;&#32;&#32;uint32_t&#32;extensionCount&#32;=&#32;0;
<anchor xml:id="_device_8cpp_source_1l00281"/>00281 &#32;&#32;&#32;&#32;vkEnumerateInstanceExtensionProperties(<emphasis role="keyword">nullptr</emphasis>,&#32;&amp;extensionCount,&#32;<emphasis role="keyword">nullptr</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00282"/>00282 &#32;&#32;&#32;&#32;std::vector&lt;VkExtensionProperties&gt;&#32;extensions(extensionCount);
<anchor xml:id="_device_8cpp_source_1l00283"/>00283 &#32;&#32;&#32;&#32;vkEnumerateInstanceExtensionProperties(<emphasis role="keyword">nullptr</emphasis>,&#32;&amp;extensionCount,&#32;extensions.data());
<anchor xml:id="_device_8cpp_source_1l00284"/>00284 
<anchor xml:id="_device_8cpp_source_1l00285"/>00285 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;available&#32;extensions:&quot;</emphasis>&#32;&lt;&lt;&#32;std::endl;
<anchor xml:id="_device_8cpp_source_1l00286"/>00286 &#32;&#32;&#32;&#32;std::unordered_set&lt;std::string&gt;&#32;available;
<anchor xml:id="_device_8cpp_source_1l00287"/>00287 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">auto</emphasis>&#32;&amp;extension&#32;:&#32;extensions)&#32;{
<anchor xml:id="_device_8cpp_source_1l00288"/>00288 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;\t&quot;</emphasis>&#32;&lt;&lt;&#32;extension.extensionName&#32;&lt;&lt;&#32;std::endl;
<anchor xml:id="_device_8cpp_source_1l00289"/>00289 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;available.insert(extension.extensionName);
<anchor xml:id="_device_8cpp_source_1l00290"/>00290 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00291"/>00291 
<anchor xml:id="_device_8cpp_source_1l00292"/>00292 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;required&#32;extensions:&quot;</emphasis>&#32;&lt;&lt;&#32;std::endl;
<anchor xml:id="_device_8cpp_source_1l00293"/>00293 &#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;requiredExtensions&#32;=&#32;getRequiredExtensions();
<anchor xml:id="_device_8cpp_source_1l00294"/>00294 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">auto</emphasis>&#32;&amp;required&#32;:&#32;requiredExtensions)&#32;{
<anchor xml:id="_device_8cpp_source_1l00295"/>00295 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;\t&quot;</emphasis>&#32;&lt;&lt;&#32;required&#32;&lt;&lt;&#32;std::endl;
<anchor xml:id="_device_8cpp_source_1l00296"/>00296 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(available.find(required)&#32;==&#32;available.end())&#32;{
<anchor xml:id="_device_8cpp_source_1l00297"/>00297 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">throw</emphasis>&#32;std::runtime_error(<emphasis role="stringliteral">&quot;Missing&#32;required&#32;glfw&#32;extension&quot;</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00298"/>00298 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00299"/>00299 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00300"/>00300 }
<anchor xml:id="_device_8cpp_source_1l00301"/>00301 
<anchor xml:id="_device_8cpp_source_1l00302"/>00302 <emphasis role="keywordtype">bool</emphasis>&#32;Device::checkDeviceExtensionSupport(VkPhysicalDevice&#32;device)&#32;{
<anchor xml:id="_device_8cpp_source_1l00303"/>00303 &#32;&#32;&#32;&#32;uint32_t&#32;extensionCount;
<anchor xml:id="_device_8cpp_source_1l00304"/>00304 &#32;&#32;&#32;&#32;vkEnumerateDeviceExtensionProperties(<link linkend="_class_blocky_vulkan_1_1_device_1abd0f1af74c6907d4354112e1291db9aa">device</link>,&#32;<emphasis role="keyword">nullptr</emphasis>,&#32;&amp;extensionCount,&#32;<emphasis role="keyword">nullptr</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00305"/>00305 
<anchor xml:id="_device_8cpp_source_1l00306"/>00306 &#32;&#32;&#32;&#32;std::vector&lt;VkExtensionProperties&gt;&#32;availableExtensions(extensionCount);
<anchor xml:id="_device_8cpp_source_1l00307"/>00307 &#32;&#32;&#32;&#32;vkEnumerateDeviceExtensionProperties(
<anchor xml:id="_device_8cpp_source_1l00308"/>00308 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_class_blocky_vulkan_1_1_device_1abd0f1af74c6907d4354112e1291db9aa">device</link>,
<anchor xml:id="_device_8cpp_source_1l00309"/>00309 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">nullptr</emphasis>,
<anchor xml:id="_device_8cpp_source_1l00310"/>00310 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&amp;extensionCount,
<anchor xml:id="_device_8cpp_source_1l00311"/>00311 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;availableExtensions.data());
<anchor xml:id="_device_8cpp_source_1l00312"/>00312 
<anchor xml:id="_device_8cpp_source_1l00313"/>00313 &#32;&#32;&#32;&#32;std::set&lt;std::string&gt;&#32;requiredExtensions(deviceExtensions.begin(),&#32;deviceExtensions.end());
<anchor xml:id="_device_8cpp_source_1l00314"/>00314 
<anchor xml:id="_device_8cpp_source_1l00315"/>00315 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">auto</emphasis>&#32;&amp;extension&#32;:&#32;availableExtensions)&#32;{
<anchor xml:id="_device_8cpp_source_1l00316"/>00316 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;requiredExtensions.erase(extension.extensionName);
<anchor xml:id="_device_8cpp_source_1l00317"/>00317 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00318"/>00318 
<anchor xml:id="_device_8cpp_source_1l00319"/>00319 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;requiredExtensions.empty();
<anchor xml:id="_device_8cpp_source_1l00320"/>00320 }
<anchor xml:id="_device_8cpp_source_1l00321"/>00321 
<anchor xml:id="_device_8cpp_source_1l00322"/>00322 QueueFamilyIndices&#32;Device::findQueueFamilies(VkPhysicalDevice&#32;device)&#32;{
<anchor xml:id="_device_8cpp_source_1l00323"/>00323 &#32;&#32;&#32;&#32;QueueFamilyIndices&#32;indices;
<anchor xml:id="_device_8cpp_source_1l00324"/>00324 
<anchor xml:id="_device_8cpp_source_1l00325"/>00325 &#32;&#32;&#32;&#32;uint32_t&#32;queueFamilyCount&#32;=&#32;0;
<anchor xml:id="_device_8cpp_source_1l00326"/>00326 &#32;&#32;&#32;&#32;vkGetPhysicalDeviceQueueFamilyProperties(<link linkend="_class_blocky_vulkan_1_1_device_1abd0f1af74c6907d4354112e1291db9aa">device</link>,&#32;&amp;queueFamilyCount,&#32;<emphasis role="keyword">nullptr</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00327"/>00327 
<anchor xml:id="_device_8cpp_source_1l00328"/>00328 &#32;&#32;&#32;&#32;std::vector&lt;VkQueueFamilyProperties&gt;&#32;queueFamilies(queueFamilyCount);
<anchor xml:id="_device_8cpp_source_1l00329"/>00329 &#32;&#32;&#32;&#32;vkGetPhysicalDeviceQueueFamilyProperties(<link linkend="_class_blocky_vulkan_1_1_device_1abd0f1af74c6907d4354112e1291db9aa">device</link>,&#32;&amp;queueFamilyCount,&#32;queueFamilies.data());
<anchor xml:id="_device_8cpp_source_1l00330"/>00330 
<anchor xml:id="_device_8cpp_source_1l00331"/>00331 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;
<anchor xml:id="_device_8cpp_source_1l00332"/>00332 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keyword">auto</emphasis>&#32;&amp;queueFamily&#32;:&#32;queueFamilies)&#32;{
<anchor xml:id="_device_8cpp_source_1l00333"/>00333 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(queueFamily.queueCount&#32;&gt;&#32;0&#32;&amp;&amp;&#32;queueFamily.queueFlags&#32;&amp;&#32;VK_QUEUE_GRAPHICS_BIT)&#32;{
<anchor xml:id="_device_8cpp_source_1l00334"/>00334 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;indices.graphicsFamily&#32;=&#32;i;
<anchor xml:id="_device_8cpp_source_1l00335"/>00335 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;indices.graphicsFamilyHasValue&#32;=&#32;<emphasis role="keyword">true</emphasis>;
<anchor xml:id="_device_8cpp_source_1l00336"/>00336 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00337"/>00337 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;VkBool32&#32;presentSupport&#32;=&#32;<emphasis role="keyword">false</emphasis>;
<anchor xml:id="_device_8cpp_source_1l00338"/>00338 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;vkGetPhysicalDeviceSurfaceSupportKHR(<link linkend="_class_blocky_vulkan_1_1_device_1abd0f1af74c6907d4354112e1291db9aa">device</link>,&#32;i,&#32;surface_,&#32;&amp;presentSupport);
<anchor xml:id="_device_8cpp_source_1l00339"/>00339 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(queueFamily.queueCount&#32;&gt;&#32;0&#32;&amp;&amp;&#32;presentSupport)&#32;{
<anchor xml:id="_device_8cpp_source_1l00340"/>00340 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;indices.presentFamily&#32;=&#32;i;
<anchor xml:id="_device_8cpp_source_1l00341"/>00341 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;indices.presentFamilyHasValue&#32;=&#32;<emphasis role="keyword">true</emphasis>;
<anchor xml:id="_device_8cpp_source_1l00342"/>00342 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00343"/>00343 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(indices.isComplete())&#32;{
<anchor xml:id="_device_8cpp_source_1l00344"/>00344 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
<anchor xml:id="_device_8cpp_source_1l00345"/>00345 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00346"/>00346 
<anchor xml:id="_device_8cpp_source_1l00347"/>00347 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;i++;
<anchor xml:id="_device_8cpp_source_1l00348"/>00348 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00349"/>00349 
<anchor xml:id="_device_8cpp_source_1l00350"/>00350 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;indices;
<anchor xml:id="_device_8cpp_source_1l00351"/>00351 }
<anchor xml:id="_device_8cpp_source_1l00352"/>00352 
<anchor xml:id="_device_8cpp_source_1l00353"/>00353 SwapChainSupportDetails&#32;Device::querySwapChainSupport(VkPhysicalDevice&#32;device)&#32;{
<anchor xml:id="_device_8cpp_source_1l00354"/>00354 &#32;&#32;&#32;&#32;SwapChainSupportDetails&#32;details;
<anchor xml:id="_device_8cpp_source_1l00355"/>00355 &#32;&#32;&#32;&#32;vkGetPhysicalDeviceSurfaceCapabilitiesKHR(<link linkend="_class_blocky_vulkan_1_1_device_1abd0f1af74c6907d4354112e1291db9aa">device</link>,&#32;surface_,&#32;&amp;details.capabilities);
<anchor xml:id="_device_8cpp_source_1l00356"/>00356 
<anchor xml:id="_device_8cpp_source_1l00357"/>00357 &#32;&#32;&#32;&#32;uint32_t&#32;formatCount;
<anchor xml:id="_device_8cpp_source_1l00358"/>00358 &#32;&#32;&#32;&#32;vkGetPhysicalDeviceSurfaceFormatsKHR(<link linkend="_class_blocky_vulkan_1_1_device_1abd0f1af74c6907d4354112e1291db9aa">device</link>,&#32;surface_,&#32;&amp;formatCount,&#32;<emphasis role="keyword">nullptr</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00359"/>00359 
<anchor xml:id="_device_8cpp_source_1l00360"/>00360 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(formatCount&#32;!=&#32;0)&#32;{
<anchor xml:id="_device_8cpp_source_1l00361"/>00361 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;details.formats.resize(formatCount);
<anchor xml:id="_device_8cpp_source_1l00362"/>00362 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;vkGetPhysicalDeviceSurfaceFormatsKHR(<link linkend="_class_blocky_vulkan_1_1_device_1abd0f1af74c6907d4354112e1291db9aa">device</link>,&#32;surface_,&#32;&amp;formatCount,&#32;details.formats.data());
<anchor xml:id="_device_8cpp_source_1l00363"/>00363 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00364"/>00364 
<anchor xml:id="_device_8cpp_source_1l00365"/>00365 &#32;&#32;&#32;&#32;uint32_t&#32;presentModeCount;
<anchor xml:id="_device_8cpp_source_1l00366"/>00366 &#32;&#32;&#32;&#32;vkGetPhysicalDeviceSurfacePresentModesKHR(<link linkend="_class_blocky_vulkan_1_1_device_1abd0f1af74c6907d4354112e1291db9aa">device</link>,&#32;surface_,&#32;&amp;presentModeCount,&#32;<emphasis role="keyword">nullptr</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00367"/>00367 
<anchor xml:id="_device_8cpp_source_1l00368"/>00368 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(presentModeCount&#32;!=&#32;0)&#32;{
<anchor xml:id="_device_8cpp_source_1l00369"/>00369 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;details.presentModes.resize(presentModeCount);
<anchor xml:id="_device_8cpp_source_1l00370"/>00370 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;vkGetPhysicalDeviceSurfacePresentModesKHR(
<anchor xml:id="_device_8cpp_source_1l00371"/>00371 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<link linkend="_class_blocky_vulkan_1_1_device_1abd0f1af74c6907d4354112e1291db9aa">device</link>,
<anchor xml:id="_device_8cpp_source_1l00372"/>00372 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;surface_,
<anchor xml:id="_device_8cpp_source_1l00373"/>00373 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&amp;presentModeCount,
<anchor xml:id="_device_8cpp_source_1l00374"/>00374 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;details.presentModes.data());
<anchor xml:id="_device_8cpp_source_1l00375"/>00375 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00376"/>00376 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;details;
<anchor xml:id="_device_8cpp_source_1l00377"/>00377 }
<anchor xml:id="_device_8cpp_source_1l00378"/>00378 
<anchor xml:id="_device_8cpp_source_1l00379"/><link linkend="_class_blocky_vulkan_1_1_device_1a4d650743baa310cfab8703488586d27c">00379</link> VkFormat&#32;<link linkend="_class_blocky_vulkan_1_1_device_1a4d650743baa310cfab8703488586d27c">Device::findSupportedFormat</link>(
<anchor xml:id="_device_8cpp_source_1l00380"/>00380 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;std::vector&lt;VkFormat&gt;&#32;&amp;candidates,&#32;VkImageTiling&#32;tiling,&#32;VkFormatFeatureFlags&#32;features)&#32;{
<anchor xml:id="_device_8cpp_source_1l00381"/>00381 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(VkFormat&#32;format&#32;:&#32;candidates)&#32;{
<anchor xml:id="_device_8cpp_source_1l00382"/>00382 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;VkFormatProperties&#32;props;
<anchor xml:id="_device_8cpp_source_1l00383"/>00383 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;vkGetPhysicalDeviceFormatProperties(physicalDevice,&#32;format,&#32;&amp;props);
<anchor xml:id="_device_8cpp_source_1l00384"/>00384 
<anchor xml:id="_device_8cpp_source_1l00385"/>00385 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(tiling&#32;==&#32;VK_IMAGE_TILING_LINEAR&#32;&amp;&amp;&#32;(props.linearTilingFeatures&#32;&amp;&#32;features)&#32;==&#32;features)&#32;{
<anchor xml:id="_device_8cpp_source_1l00386"/>00386 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;format;
<anchor xml:id="_device_8cpp_source_1l00387"/>00387 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(
<anchor xml:id="_device_8cpp_source_1l00388"/>00388 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;tiling&#32;==&#32;VK_IMAGE_TILING_OPTIMAL&#32;&amp;&amp;&#32;(props.optimalTilingFeatures&#32;&amp;&#32;features)&#32;==&#32;features)&#32;{
<anchor xml:id="_device_8cpp_source_1l00389"/>00389 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;format;
<anchor xml:id="_device_8cpp_source_1l00390"/>00390 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00391"/>00391 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00392"/>00392 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">throw</emphasis>&#32;std::runtime_error(<emphasis role="stringliteral">&quot;failed&#32;to&#32;find&#32;supported&#32;format!&quot;</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00393"/>00393 }
<anchor xml:id="_device_8cpp_source_1l00394"/>00394 
<anchor xml:id="_device_8cpp_source_1l00395"/><link linkend="_class_blocky_vulkan_1_1_device_1ad617fcdea6a8baf996e01daf07e2ea81">00395</link> uint32_t&#32;<link linkend="_class_blocky_vulkan_1_1_device_1ad617fcdea6a8baf996e01daf07e2ea81">Device::findMemoryType</link>(uint32_t&#32;typeFilter,&#32;VkMemoryPropertyFlags&#32;properties)&#32;{
<anchor xml:id="_device_8cpp_source_1l00396"/>00396 &#32;&#32;&#32;&#32;VkPhysicalDeviceMemoryProperties&#32;memProperties;
<anchor xml:id="_device_8cpp_source_1l00397"/>00397 &#32;&#32;&#32;&#32;vkGetPhysicalDeviceMemoryProperties(physicalDevice,&#32;&amp;memProperties);
<anchor xml:id="_device_8cpp_source_1l00398"/>00398 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(uint32_t&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;memProperties.memoryTypeCount;&#32;i++)&#32;{
<anchor xml:id="_device_8cpp_source_1l00399"/>00399 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;((typeFilter&#32;&amp;&#32;(1&#32;&lt;&lt;&#32;i))&#32;&amp;&amp;
<anchor xml:id="_device_8cpp_source_1l00400"/>00400 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;(memProperties.memoryTypes[i].propertyFlags&#32;&amp;&#32;<link linkend="_class_blocky_vulkan_1_1_device_1aa21b177cd0be90aec7ecb0179fd7e734">properties</link>)&#32;==&#32;<link linkend="_class_blocky_vulkan_1_1_device_1aa21b177cd0be90aec7ecb0179fd7e734">properties</link>)&#32;{
<anchor xml:id="_device_8cpp_source_1l00401"/>00401 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;i;
<anchor xml:id="_device_8cpp_source_1l00402"/>00402 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00403"/>00403 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00404"/>00404 
<anchor xml:id="_device_8cpp_source_1l00405"/>00405 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">throw</emphasis>&#32;std::runtime_error(<emphasis role="stringliteral">&quot;failed&#32;to&#32;find&#32;suitable&#32;memory&#32;type!&quot;</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00406"/>00406 }
<anchor xml:id="_device_8cpp_source_1l00407"/>00407 
<anchor xml:id="_device_8cpp_source_1l00408"/><link linkend="_class_blocky_vulkan_1_1_device_1a4de673bdd57fa7f666ed13785178ef64">00408</link> <emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_blocky_vulkan_1_1_device_1a4de673bdd57fa7f666ed13785178ef64">Device::createBuffer</link>(
<anchor xml:id="_device_8cpp_source_1l00409"/>00409 &#32;&#32;&#32;&#32;VkDeviceSize&#32;size,
<anchor xml:id="_device_8cpp_source_1l00410"/>00410 &#32;&#32;&#32;&#32;VkBufferUsageFlags&#32;usage,
<anchor xml:id="_device_8cpp_source_1l00411"/>00411 &#32;&#32;&#32;&#32;VkMemoryPropertyFlags&#32;properties,
<anchor xml:id="_device_8cpp_source_1l00412"/>00412 &#32;&#32;&#32;&#32;VkBuffer&#32;&amp;buffer,
<anchor xml:id="_device_8cpp_source_1l00413"/>00413 &#32;&#32;&#32;&#32;VkDeviceMemory&#32;&amp;bufferMemory)&#32;{
<anchor xml:id="_device_8cpp_source_1l00414"/>00414 &#32;&#32;&#32;&#32;VkBufferCreateInfo&#32;bufferInfo{};
<anchor xml:id="_device_8cpp_source_1l00415"/>00415 &#32;&#32;&#32;&#32;bufferInfo.sType&#32;=&#32;VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
<anchor xml:id="_device_8cpp_source_1l00416"/>00416 &#32;&#32;&#32;&#32;bufferInfo.size&#32;=&#32;size;
<anchor xml:id="_device_8cpp_source_1l00417"/>00417 &#32;&#32;&#32;&#32;bufferInfo.usage&#32;=&#32;usage;
<anchor xml:id="_device_8cpp_source_1l00418"/>00418 &#32;&#32;&#32;&#32;bufferInfo.sharingMode&#32;=&#32;VK_SHARING_MODE_EXCLUSIVE;
<anchor xml:id="_device_8cpp_source_1l00419"/>00419 
<anchor xml:id="_device_8cpp_source_1l00420"/>00420 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(vkCreateBuffer(device_,&#32;&amp;bufferInfo,&#32;<emphasis role="keyword">nullptr</emphasis>,&#32;&amp;buffer)&#32;!=&#32;VK_SUCCESS)&#32;{
<anchor xml:id="_device_8cpp_source_1l00421"/>00421 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">throw</emphasis>&#32;std::runtime_error(<emphasis role="stringliteral">&quot;failed&#32;to&#32;create&#32;vertex&#32;buffer!&quot;</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00422"/>00422 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00423"/>00423 
<anchor xml:id="_device_8cpp_source_1l00424"/>00424 &#32;&#32;&#32;&#32;VkMemoryRequirements&#32;memRequirements;
<anchor xml:id="_device_8cpp_source_1l00425"/>00425 &#32;&#32;&#32;&#32;vkGetBufferMemoryRequirements(device_,&#32;buffer,&#32;&amp;memRequirements);
<anchor xml:id="_device_8cpp_source_1l00426"/>00426 
<anchor xml:id="_device_8cpp_source_1l00427"/>00427 &#32;&#32;&#32;&#32;VkMemoryAllocateInfo&#32;allocInfo{};
<anchor xml:id="_device_8cpp_source_1l00428"/>00428 &#32;&#32;&#32;&#32;allocInfo.sType&#32;=&#32;VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
<anchor xml:id="_device_8cpp_source_1l00429"/>00429 &#32;&#32;&#32;&#32;allocInfo.allocationSize&#32;=&#32;memRequirements.size;
<anchor xml:id="_device_8cpp_source_1l00430"/>00430 &#32;&#32;&#32;&#32;allocInfo.memoryTypeIndex&#32;=&#32;<link linkend="_class_blocky_vulkan_1_1_device_1ad617fcdea6a8baf996e01daf07e2ea81">findMemoryType</link>(memRequirements.memoryTypeBits,&#32;<link linkend="_class_blocky_vulkan_1_1_device_1aa21b177cd0be90aec7ecb0179fd7e734">properties</link>);
<anchor xml:id="_device_8cpp_source_1l00431"/>00431 
<anchor xml:id="_device_8cpp_source_1l00432"/>00432 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(vkAllocateMemory(device_,&#32;&amp;allocInfo,&#32;<emphasis role="keyword">nullptr</emphasis>,&#32;&amp;bufferMemory)&#32;!=&#32;VK_SUCCESS)&#32;{
<anchor xml:id="_device_8cpp_source_1l00433"/>00433 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">throw</emphasis>&#32;std::runtime_error(<emphasis role="stringliteral">&quot;failed&#32;to&#32;allocate&#32;vertex&#32;buffer&#32;memory!&quot;</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00434"/>00434 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00435"/>00435 
<anchor xml:id="_device_8cpp_source_1l00436"/>00436 &#32;&#32;&#32;&#32;vkBindBufferMemory(device_,&#32;buffer,&#32;bufferMemory,&#32;0);
<anchor xml:id="_device_8cpp_source_1l00437"/>00437 }
<anchor xml:id="_device_8cpp_source_1l00438"/>00438 
<anchor xml:id="_device_8cpp_source_1l00439"/><link linkend="_class_blocky_vulkan_1_1_device_1a8baa78622c491d96d97538c45e838853">00439</link> VkCommandBuffer&#32;<link linkend="_class_blocky_vulkan_1_1_device_1a8baa78622c491d96d97538c45e838853">Device::beginSingleTimeCommands</link>()&#32;{
<anchor xml:id="_device_8cpp_source_1l00440"/>00440 &#32;&#32;&#32;&#32;VkCommandBufferAllocateInfo&#32;allocInfo{};
<anchor xml:id="_device_8cpp_source_1l00441"/>00441 &#32;&#32;&#32;&#32;allocInfo.sType&#32;=&#32;VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
<anchor xml:id="_device_8cpp_source_1l00442"/>00442 &#32;&#32;&#32;&#32;allocInfo.level&#32;=&#32;VK_COMMAND_BUFFER_LEVEL_PRIMARY;
<anchor xml:id="_device_8cpp_source_1l00443"/>00443 &#32;&#32;&#32;&#32;allocInfo.commandPool&#32;=&#32;commandPool;
<anchor xml:id="_device_8cpp_source_1l00444"/>00444 &#32;&#32;&#32;&#32;allocInfo.commandBufferCount&#32;=&#32;1;
<anchor xml:id="_device_8cpp_source_1l00445"/>00445 
<anchor xml:id="_device_8cpp_source_1l00446"/>00446 &#32;&#32;&#32;&#32;VkCommandBuffer&#32;commandBuffer;
<anchor xml:id="_device_8cpp_source_1l00447"/>00447 &#32;&#32;&#32;&#32;vkAllocateCommandBuffers(device_,&#32;&amp;allocInfo,&#32;&amp;commandBuffer);
<anchor xml:id="_device_8cpp_source_1l00448"/>00448 
<anchor xml:id="_device_8cpp_source_1l00449"/>00449 &#32;&#32;&#32;&#32;VkCommandBufferBeginInfo&#32;beginInfo{};
<anchor xml:id="_device_8cpp_source_1l00450"/>00450 &#32;&#32;&#32;&#32;beginInfo.sType&#32;=&#32;VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
<anchor xml:id="_device_8cpp_source_1l00451"/>00451 &#32;&#32;&#32;&#32;beginInfo.flags&#32;=&#32;VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;
<anchor xml:id="_device_8cpp_source_1l00452"/>00452 
<anchor xml:id="_device_8cpp_source_1l00453"/>00453 &#32;&#32;&#32;&#32;vkBeginCommandBuffer(commandBuffer,&#32;&amp;beginInfo);
<anchor xml:id="_device_8cpp_source_1l00454"/>00454 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;commandBuffer;
<anchor xml:id="_device_8cpp_source_1l00455"/>00455 }
<anchor xml:id="_device_8cpp_source_1l00456"/>00456 
<anchor xml:id="_device_8cpp_source_1l00457"/><link linkend="_class_blocky_vulkan_1_1_device_1a31bf87be17d10e28137b9245afbe2db5">00457</link> <emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_blocky_vulkan_1_1_device_1a31bf87be17d10e28137b9245afbe2db5">Device::endSingleTimeCommands</link>(VkCommandBuffer&#32;commandBuffer)&#32;{
<anchor xml:id="_device_8cpp_source_1l00458"/>00458 &#32;&#32;&#32;&#32;vkEndCommandBuffer(commandBuffer);
<anchor xml:id="_device_8cpp_source_1l00459"/>00459 
<anchor xml:id="_device_8cpp_source_1l00460"/>00460 &#32;&#32;&#32;&#32;VkSubmitInfo&#32;submitInfo{};
<anchor xml:id="_device_8cpp_source_1l00461"/>00461 &#32;&#32;&#32;&#32;submitInfo.sType&#32;=&#32;VK_STRUCTURE_TYPE_SUBMIT_INFO;
<anchor xml:id="_device_8cpp_source_1l00462"/>00462 &#32;&#32;&#32;&#32;submitInfo.commandBufferCount&#32;=&#32;1;
<anchor xml:id="_device_8cpp_source_1l00463"/>00463 &#32;&#32;&#32;&#32;submitInfo.pCommandBuffers&#32;=&#32;&amp;commandBuffer;
<anchor xml:id="_device_8cpp_source_1l00464"/>00464 
<anchor xml:id="_device_8cpp_source_1l00465"/>00465 &#32;&#32;&#32;&#32;vkQueueSubmit(graphicsQueue_,&#32;1,&#32;&amp;submitInfo,&#32;VK_NULL_HANDLE);
<anchor xml:id="_device_8cpp_source_1l00466"/>00466 &#32;&#32;&#32;&#32;vkQueueWaitIdle(graphicsQueue_);
<anchor xml:id="_device_8cpp_source_1l00467"/>00467 
<anchor xml:id="_device_8cpp_source_1l00468"/>00468 &#32;&#32;&#32;&#32;vkFreeCommandBuffers(device_,&#32;commandPool,&#32;1,&#32;&amp;commandBuffer);
<anchor xml:id="_device_8cpp_source_1l00469"/>00469 }
<anchor xml:id="_device_8cpp_source_1l00470"/>00470 
<anchor xml:id="_device_8cpp_source_1l00471"/><link linkend="_class_blocky_vulkan_1_1_device_1a82e77bebd10b053b0e6aebf5eda4ccd5">00471</link> <emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_blocky_vulkan_1_1_device_1a82e77bebd10b053b0e6aebf5eda4ccd5">Device::copyBuffer</link>(VkBuffer&#32;srcBuffer,&#32;VkBuffer&#32;dstBuffer,&#32;VkDeviceSize&#32;size)&#32;{
<anchor xml:id="_device_8cpp_source_1l00472"/>00472 &#32;&#32;&#32;&#32;VkCommandBuffer&#32;commandBuffer&#32;=&#32;<link linkend="_class_blocky_vulkan_1_1_device_1a8baa78622c491d96d97538c45e838853">beginSingleTimeCommands</link>();
<anchor xml:id="_device_8cpp_source_1l00473"/>00473 
<anchor xml:id="_device_8cpp_source_1l00474"/>00474 &#32;&#32;&#32;&#32;VkBufferCopy&#32;copyRegion{};
<anchor xml:id="_device_8cpp_source_1l00475"/>00475 &#32;&#32;&#32;&#32;copyRegion.srcOffset&#32;=&#32;0;&#32;&#32;<emphasis role="comment">//&#32;Optional</emphasis>
<anchor xml:id="_device_8cpp_source_1l00476"/>00476 &#32;&#32;&#32;&#32;copyRegion.dstOffset&#32;=&#32;0;&#32;&#32;<emphasis role="comment">//&#32;Optional</emphasis>
<anchor xml:id="_device_8cpp_source_1l00477"/>00477 &#32;&#32;&#32;&#32;copyRegion.size&#32;=&#32;size;
<anchor xml:id="_device_8cpp_source_1l00478"/>00478 &#32;&#32;&#32;&#32;vkCmdCopyBuffer(commandBuffer,&#32;srcBuffer,&#32;dstBuffer,&#32;1,&#32;&amp;copyRegion);
<anchor xml:id="_device_8cpp_source_1l00479"/>00479 
<anchor xml:id="_device_8cpp_source_1l00480"/>00480 &#32;&#32;&#32;&#32;<link linkend="_class_blocky_vulkan_1_1_device_1a31bf87be17d10e28137b9245afbe2db5">endSingleTimeCommands</link>(commandBuffer);
<anchor xml:id="_device_8cpp_source_1l00481"/>00481 }
<anchor xml:id="_device_8cpp_source_1l00482"/>00482 
<anchor xml:id="_device_8cpp_source_1l00483"/><link linkend="_class_blocky_vulkan_1_1_device_1ae1628156841c3c8d2ff49b85cec4efc6">00483</link> <emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_blocky_vulkan_1_1_device_1ae1628156841c3c8d2ff49b85cec4efc6">Device::copyBufferToImage</link>(
<anchor xml:id="_device_8cpp_source_1l00484"/>00484 &#32;&#32;&#32;&#32;VkBuffer&#32;buffer,&#32;VkImage&#32;image,&#32;uint32_t&#32;width,&#32;uint32_t&#32;height,&#32;uint32_t&#32;layerCount)&#32;{
<anchor xml:id="_device_8cpp_source_1l00485"/>00485 &#32;&#32;&#32;&#32;VkCommandBuffer&#32;commandBuffer&#32;=&#32;<link linkend="_class_blocky_vulkan_1_1_device_1a8baa78622c491d96d97538c45e838853">beginSingleTimeCommands</link>();
<anchor xml:id="_device_8cpp_source_1l00486"/>00486 
<anchor xml:id="_device_8cpp_source_1l00487"/>00487 &#32;&#32;&#32;&#32;VkBufferImageCopy&#32;region{};
<anchor xml:id="_device_8cpp_source_1l00488"/>00488 &#32;&#32;&#32;&#32;region.bufferOffset&#32;=&#32;0;
<anchor xml:id="_device_8cpp_source_1l00489"/>00489 &#32;&#32;&#32;&#32;region.bufferRowLength&#32;=&#32;0;
<anchor xml:id="_device_8cpp_source_1l00490"/>00490 &#32;&#32;&#32;&#32;region.bufferImageHeight&#32;=&#32;0;
<anchor xml:id="_device_8cpp_source_1l00491"/>00491 
<anchor xml:id="_device_8cpp_source_1l00492"/>00492 &#32;&#32;&#32;&#32;region.imageSubresource.aspectMask&#32;=&#32;VK_IMAGE_ASPECT_COLOR_BIT;
<anchor xml:id="_device_8cpp_source_1l00493"/>00493 &#32;&#32;&#32;&#32;region.imageSubresource.mipLevel&#32;=&#32;0;
<anchor xml:id="_device_8cpp_source_1l00494"/>00494 &#32;&#32;&#32;&#32;region.imageSubresource.baseArrayLayer&#32;=&#32;0;
<anchor xml:id="_device_8cpp_source_1l00495"/>00495 &#32;&#32;&#32;&#32;region.imageSubresource.layerCount&#32;=&#32;layerCount;
<anchor xml:id="_device_8cpp_source_1l00496"/>00496 
<anchor xml:id="_device_8cpp_source_1l00497"/>00497 &#32;&#32;&#32;&#32;region.imageOffset&#32;=&#32;{0,&#32;0,&#32;0};
<anchor xml:id="_device_8cpp_source_1l00498"/>00498 &#32;&#32;&#32;&#32;region.imageExtent&#32;=&#32;{width,&#32;height,&#32;1};
<anchor xml:id="_device_8cpp_source_1l00499"/>00499 
<anchor xml:id="_device_8cpp_source_1l00500"/>00500 &#32;&#32;&#32;&#32;vkCmdCopyBufferToImage(
<anchor xml:id="_device_8cpp_source_1l00501"/>00501 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;commandBuffer,
<anchor xml:id="_device_8cpp_source_1l00502"/>00502 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;buffer,
<anchor xml:id="_device_8cpp_source_1l00503"/>00503 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;image,
<anchor xml:id="_device_8cpp_source_1l00504"/>00504 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
<anchor xml:id="_device_8cpp_source_1l00505"/>00505 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;1,
<anchor xml:id="_device_8cpp_source_1l00506"/>00506 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&amp;region);
<anchor xml:id="_device_8cpp_source_1l00507"/>00507 &#32;&#32;&#32;&#32;<link linkend="_class_blocky_vulkan_1_1_device_1a31bf87be17d10e28137b9245afbe2db5">endSingleTimeCommands</link>(commandBuffer);
<anchor xml:id="_device_8cpp_source_1l00508"/>00508 }
<anchor xml:id="_device_8cpp_source_1l00509"/>00509 
<anchor xml:id="_device_8cpp_source_1l00510"/><link linkend="_class_blocky_vulkan_1_1_device_1aacb612b684d04f19342f6537d207fb15">00510</link> <emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_blocky_vulkan_1_1_device_1aacb612b684d04f19342f6537d207fb15">Device::createImageWithInfo</link>(
<anchor xml:id="_device_8cpp_source_1l00511"/>00511 &#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;VkImageCreateInfo&#32;&amp;imageInfo,
<anchor xml:id="_device_8cpp_source_1l00512"/>00512 &#32;&#32;&#32;&#32;VkMemoryPropertyFlags&#32;properties,
<anchor xml:id="_device_8cpp_source_1l00513"/>00513 &#32;&#32;&#32;&#32;VkImage&#32;&amp;image,
<anchor xml:id="_device_8cpp_source_1l00514"/>00514 &#32;&#32;&#32;&#32;VkDeviceMemory&#32;&amp;imageMemory)&#32;{
<anchor xml:id="_device_8cpp_source_1l00515"/>00515 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(vkCreateImage(device_,&#32;&amp;imageInfo,&#32;<emphasis role="keyword">nullptr</emphasis>,&#32;&amp;image)&#32;!=&#32;VK_SUCCESS)&#32;{
<anchor xml:id="_device_8cpp_source_1l00516"/>00516 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">throw</emphasis>&#32;std::runtime_error(<emphasis role="stringliteral">&quot;failed&#32;to&#32;create&#32;image!&quot;</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00517"/>00517 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00518"/>00518 
<anchor xml:id="_device_8cpp_source_1l00519"/>00519 &#32;&#32;&#32;&#32;VkMemoryRequirements&#32;memRequirements;
<anchor xml:id="_device_8cpp_source_1l00520"/>00520 &#32;&#32;&#32;&#32;vkGetImageMemoryRequirements(device_,&#32;image,&#32;&amp;memRequirements);
<anchor xml:id="_device_8cpp_source_1l00521"/>00521 
<anchor xml:id="_device_8cpp_source_1l00522"/>00522 &#32;&#32;&#32;&#32;VkMemoryAllocateInfo&#32;allocInfo{};
<anchor xml:id="_device_8cpp_source_1l00523"/>00523 &#32;&#32;&#32;&#32;allocInfo.sType&#32;=&#32;VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
<anchor xml:id="_device_8cpp_source_1l00524"/>00524 &#32;&#32;&#32;&#32;allocInfo.allocationSize&#32;=&#32;memRequirements.size;
<anchor xml:id="_device_8cpp_source_1l00525"/>00525 &#32;&#32;&#32;&#32;allocInfo.memoryTypeIndex&#32;=&#32;<link linkend="_class_blocky_vulkan_1_1_device_1ad617fcdea6a8baf996e01daf07e2ea81">findMemoryType</link>(memRequirements.memoryTypeBits,&#32;<link linkend="_class_blocky_vulkan_1_1_device_1aa21b177cd0be90aec7ecb0179fd7e734">properties</link>);
<anchor xml:id="_device_8cpp_source_1l00526"/>00526 
<anchor xml:id="_device_8cpp_source_1l00527"/>00527 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(vkAllocateMemory(device_,&#32;&amp;allocInfo,&#32;<emphasis role="keyword">nullptr</emphasis>,&#32;&amp;imageMemory)&#32;!=&#32;VK_SUCCESS)&#32;{
<anchor xml:id="_device_8cpp_source_1l00528"/>00528 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">throw</emphasis>&#32;std::runtime_error(<emphasis role="stringliteral">&quot;failed&#32;to&#32;allocate&#32;image&#32;memory!&quot;</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00529"/>00529 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00530"/>00530 
<anchor xml:id="_device_8cpp_source_1l00531"/>00531 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(vkBindImageMemory(device_,&#32;image,&#32;imageMemory,&#32;0)&#32;!=&#32;VK_SUCCESS)&#32;{
<anchor xml:id="_device_8cpp_source_1l00532"/>00532 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">throw</emphasis>&#32;std::runtime_error(<emphasis role="stringliteral">&quot;failed&#32;to&#32;bind&#32;image&#32;memory!&quot;</emphasis>);
<anchor xml:id="_device_8cpp_source_1l00533"/>00533 &#32;&#32;&#32;&#32;}
<anchor xml:id="_device_8cpp_source_1l00534"/>00534 }
<anchor xml:id="_device_8cpp_source_1l00535"/>00535 
<anchor xml:id="_device_8cpp_source_1l00536"/>00536 }&#32;&#32;<emphasis role="comment">//&#32;namespace&#32;BlockyVulkan</emphasis>
</programlisting></section>
